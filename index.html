<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>N-Dimensional Projection</title>
    <style>
      :root {
        color-scheme: dark;
        --bg: #05060b;
        --panel: #080a12;
        --hud-text: #ced7ff;
        --hud-muted: #8090c8;
        font-family: "Consolas", "SFMono-Regular", "Fira Code", monospace;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
        background: radial-gradient(circle at top, #0b0f1f 0%, var(--bg) 60%);
        color: var(--hud-text);
      }
      .title {
        margin: 0 0 4px;
        font-size: clamp(1.5rem, 3vw, 2.2rem);
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }
      .app {
        width: min(960px, 100%);
        display: flex;
        flex-direction: column;
        gap: 16px;
        align-items: center;
      }
      .canvas-shell {
        width: 100%;
        position: relative;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .canvas-toolbar {
        position: absolute;
        top: 16px;
        right: 16px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .canvas-pan {
        position: absolute;
        top: 16px;
        left: 16px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
      }
      .canvas-pan-row {
        display: flex;
        gap: 6px;
      }
      .canvas-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 1px solid #27304b;
        background: rgba(8, 12, 25, 0.85);
        color: var(--hud-text);
        font-size: 1.1rem;
        cursor: pointer;
        backdrop-filter: blur(4px);
        transition: transform 0.1s ease, background 0.2s ease;
      }
      .canvas-btn:active {
        transform: scale(0.96);
        background: rgba(14, 19, 34, 0.95);
      }
      .canvas-pan button {
        width: 38px;
        height: 38px;
        border-radius: 8px;
        border: 1px solid #27304b;
        background: rgba(8, 12, 25, 0.85);
        color: var(--hud-text);
        font: inherit;
        font-size: 0.95rem;
        cursor: pointer;
        backdrop-filter: blur(4px);
        transition: transform 0.1s ease, background 0.2s ease;
      }
      .canvas-pan button:active {
        transform: scale(0.97);
        background: rgba(14, 19, 34, 0.95);
      }
      canvas {
        display: block;
        width: 100%;
        max-width: 960px;
        aspect-ratio: 4 / 3;
        height: auto;
        background: #080a12;
        border-radius: 12px;
        border: 1px solid #141826;
        box-shadow: 0 20px 45px rgba(0, 0, 0, 0.55);
      }
      #hud {
        width: 100%;
        padding: 12px 16px;
        border-radius: 10px;
        border: 1px solid #141826;
        background: rgba(5, 6, 11, 0.8);
        font-size: 14px;
        line-height: 1.45;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.45);
      }
      #hud div {
        white-space: normal;
        overflow-wrap: anywhere;
      }
      .controls {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
        gap: 6px;
      }
      .controls button {
        font: inherit;
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid #27304b;
        background: #12182b;
        color: var(--hud-text);
        cursor: pointer;
        transition: transform 0.1s ease, background 0.2s ease;
      }
      .controls button:active,
      .controls button.active {
        transform: translateY(1px);
        background: #1c2440;
      }
      .controls button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }
      @media (max-width: 640px) {
        body {
          padding: 12px;
        }
        #hud {
          font-size: 12px;
          padding: 10px 12px;
        }
        .canvas-toolbar {
          top: 10px;
          right: 10px;
          gap: 6px;
        }
        .canvas-btn {
          width: 34px;
          height: 34px;
        }
        .canvas-pan {
          top: 10px;
          left: 10px;
          gap: 4px;
        }
        .canvas-pan button {
          width: 32px;
          height: 32px;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <h1 class="title">N-Dimensional Projection</h1>
      <div class="canvas-shell">
        <canvas id="projection" width="960" height="720"></canvas>
        <div class="canvas-pan" aria-label="Pan viewport">
          <button data-action="pan-up" title="Pan up">&#8593;</button>
          <div class="canvas-pan-row">
            <button data-action="pan-left" title="Pan left">&#8592;</button>
            <button data-action="pan-right" title="Pan right">&#8594;</button>
          </div>
          <button data-action="pan-down" title="Pan down">&#8595;</button>
        </div>
        <div class="canvas-toolbar" aria-label="Canvas controls">
          <button class="canvas-btn" data-action="zoom-in" title="Zoom in">+</button>
          <button class="canvas-btn" data-action="zoom-out" title="Zoom out">-</button>
        </div>
        <div id="hud"></div>
      </div>
      <div class="controls" aria-label="Controls">
        <button data-action="plane-prev">Plane &lt;</button>
        <button data-action="plane-next">Plane &gt;</button>
        <button data-action="rotate-left">Rotate &lt;</button>
        <button data-action="rotate-right">Rotate &gt;</button>
        <button data-action="shape-prev">Shape &lt;</button>
        <button data-action="shape-next">Shape &gt;</button>
        <button data-action="dimension-dec">N -</button>
        <button data-action="dimension-inc">N +</button>
        <button data-action="plane-zero">Zero plane</button>
        <button data-action="reset-angles">Reset angles</button>
        <button data-action="reset-defaults">Defaults</button>
      </div>
    </div>
    <script type="module">
      const CONFIG = {
        screenWidth: 960,
        screenHeight: 720,
        edgeColor: [200, 220, 255],
        pointColor: [255, 170, 0],
        background: "#080a12",
        cubeBaseScale: 140,
        simplexBaseScale: 350,
        orthoplexBaseScale: 300,
        manualRotationSpeed: 1.6,
        shapes: ["cube", "simplex", "orthoplex"],
      };

      const BASE_CANVAS_WIDTH = 960;
      const BASE_CANVAS_HEIGHT = 720;
      const buttonRefs = {};
      const rotationButtonBindings = [];
      const continuousInputs = {
        zoomIn: false,
        zoomOut: false,
        panUp: false,
        panDown: false,
        panLeft: false,
        panRight: false,
      };
      const pointerQuery = window.matchMedia ? window.matchMedia("(pointer: coarse)") : null;

      const ACTION_HANDLERS = {
        "shape-prev": () => adjustShape(-1),
        "shape-next": () => adjustShape(1),
        "dimension-dec": () => adjustDimension(-1),
        "dimension-inc": () => adjustDimension(1),
        "plane-prev": () => cyclePlane(-1),
        "plane-next": () => cyclePlane(1),
        "plane-zero": () => zeroSelectedPlane(),
        "reset-angles": () => resetAllAngles(),
        "reset-defaults": () => resetToDefaults(),
      };

      const wasmSupport = {
        ready: false,
        rotate: null,
        buildShape: null,
      };

      const state = {
        shapeIndex: 0,
        dimensionSetting: 3,
        polytope: null,
        dimension: 0,
        vertexCount: 0,
        planes: [],
        planesFlat: new Uint32Array(),
        angles: new Float32Array(),
        projectionMatrix: new Float32Array(),
        renderScale: 1,
        selectedPlaneIdx: 0,
        keyState: new Set(),
        lastTime: performance.now(),
        touchMode: pointerQuery ? pointerQuery.matches : false,
        zoom: 1,
        panX: 0,
        panY: 0,
      };

      const canvas = document.getElementById("projection");
      const gl = canvas.getContext("webgl2", { antialias: true }) || canvas.getContext("webgl", { antialias: true });
      const ctx = gl ? null : canvas.getContext("2d");
      const glResources = gl ? initWebGL(gl) : null;
      const hud = document.getElementById("hud");

      if (pointerQuery) {
        const handlePointerChange = (event) => {
          state.touchMode = event.matches;
          renderHud();
        };
        if (typeof pointerQuery.addEventListener === "function") {
          pointerQuery.addEventListener("change", handlePointerChange);
        } else if (typeof pointerQuery.addListener === "function") {
          pointerQuery.addListener(handlePointerChange);
        }
      }

      setupButtonControls();
      resizeCanvas();
      let resizeQueued = false;
      window.addEventListener("resize", () => {
        if (!resizeQueued) {
          resizeQueued = true;
          requestAnimationFrame(() => {
            resizeQueued = false;
            resizeCanvas();
          });
        }
      });
      canvas.addEventListener(
        "wheel",
        (event) => {
          event.preventDefault();
          if (document.activeElement !== canvas) return;
          const delta = Math.sign(event.deltaY);
          if (delta === 0) return;
          const factor = 1 + Math.min(Math.abs(event.deltaY), 400) * 0.0015;
          if (delta > 0) {
            adjustZoom(1 / factor);
          } else {
            adjustZoom(factor);
          }
        },
        { passive: false }
      );
      canvas.setAttribute("tabindex", "0");

      function canonicalShapeName(name) {
        return name === "tetra" ? "simplex" : name;
      }

      function dot(a, b) {
        let sum = 0;
        for (let i = 0; i < a.length; i++) sum += a[i] * b[i];
        return sum;
      }

      function gramSchmidt(vectors, targetDim) {
        const basis = [];
        for (const vector of vectors) {
          const w = vector.slice();
          for (const axis of basis) {
            const proj = dot(w, axis);
            for (let i = 0; i < w.length; i++) w[i] -= proj * axis[i];
          }
          const norm = Math.hypot(...w);
          if (norm <= 1e-9) continue;
          basis.push(w.map((value) => value / norm));
          if (basis.length === targetDim) break;
        }
        if (basis.length < targetDim) {
          throw new Error("Unable to construct orthonormal basis for simplex");
        }
        return basis;
      }

      function generateNCube(dimension) {
        const dim = Math.max(2, dimension);
        const vertexCount = 1 << dim;
        const vertices = new Float32Array(vertexCount * dim);
        for (let i = 0; i < vertexCount; i++) {
          for (let bit = 0; bit < dim; bit++) {
            vertices[i * dim + bit] = i & (1 << bit) ? 1 : -1;
          }
        }
        const edges = [];
        for (let i = 0; i < vertexCount; i++) {
          for (let bit = 0; bit < dim; bit++) {
            if ((i & (1 << bit)) === 0) {
              edges.push([i, i | (1 << bit)]);
            }
          }
        }
        return { vertices, edges, dim, vertexCount };
      }

      function generateRegularSimplex(dimension) {
        const dim = Math.max(2, dimension);
        const count = dim + 1;
        const centroid = 1 / count;
        const rawVertices = [];
        for (let i = 0; i < count; i++) {
          const vec = new Array(count).fill(0);
          vec[i] = 1;
          rawVertices.push(vec.map((value) => value - centroid));
        }
        const basis = gramSchmidt(rawVertices.slice(0, -1), dim);
        const vertices = new Float32Array(count * dim);
        for (let idx = 0; idx < count; idx++) {
          const coords = basis.map((axis) => dot(rawVertices[idx], axis));
          for (let d = 0; d < dim; d++) {
            vertices[idx * dim + d] = coords[d];
          }
        }
        const edges = [];
        for (let i = 0; i < count; i++) {
          for (let j = i + 1; j < count; j++) edges.push([i, j]);
        }
        return { vertices, edges, dim, vertexCount: count };
      }

      function generateOrthoplex(dimension) {
        const dim = Math.max(2, dimension);
        const vertexCount = dim * 2;
        const vertices = new Float32Array(vertexCount * dim);
        const edges = [];
        for (let axis = 0; axis < dim; axis++) {
          const posIdx = axis * 2;
          const negIdx = axis * 2 + 1;
          for (let d = 0; d < dim; d++) {
            vertices[posIdx * dim + d] = d === axis ? 1 : 0;
            vertices[negIdx * dim + d] = d === axis ? -1 : 0;
          }
        }
        for (let i = 0; i < vertexCount; i++) {
          for (let j = i + 1; j < vertexCount; j++) {
            const axisI = Math.floor(i / 2);
            const axisJ = Math.floor(j / 2);
            if (axisI !== axisJ) {
              edges.push([i, j]);
            }
          }
        }
        return { vertices, edges, dim, vertexCount };
      }

      function buildPolytope(shapeName, dimension) {
        const canonical = canonicalShapeName(shapeName);
        if (wasmSupport.ready && typeof wasmSupport.buildShape === "function") {
          try {
            return buildPolytopeFromWasm(canonical, dimension);
          } catch (error) {
            console.warn("Falling back to JS shape builder", error);
          }
        }
        return buildPolytopeFallback(canonical, dimension);
      }

      function buildPolytopeFallback(canonical, dimensionSetting) {
        if (canonical === "cube") {
          const data = generateNCube(dimensionSetting);
          return enrichFallbackPolytope(data.dim, `${data.dim}D cube`, data);
        }
        if (canonical === "simplex") {
          const data = generateRegularSimplex(dimensionSetting);
          return enrichFallbackPolytope(data.dim, `${data.dim}-simplex`, data);
        }
        if (canonical === "orthoplex") {
          const data = generateOrthoplex(dimensionSetting);
          return enrichFallbackPolytope(data.dim, `${data.dim}D orthoplex`, data);
        }
        throw new Error(`Unsupported shape '${canonical}'`);
      }

      function enrichFallbackPolytope(dim, name, data) {
        const edgeIndices = buildEdgeIndexArray(data.edges);
        return {
          name,
          dimension: dim,
          vertexCount: data.vertexCount,
          vertices: data.vertices,
          edges: data.edges,
          edgeIndices,
        };
      }

      function buildPolytopeFromWasm(canonical, dimensionSetting) {
        const shape = wasmSupport.buildShape(canonical, dimensionSetting);
        const vertices = shape.vertices();
        const edgeIndices = shape.edges();
        const edges = edgePairsFromIndices(edgeIndices);
        return {
          name: formatPolytopeName(canonical, shape.dimension),
          dimension: shape.dimension,
          vertexCount: shape.vertex_count,
          vertices,
          edges,
          edgeIndices,
        };
      }

      function formatPolytopeName(canonical, dimension) {
        if (canonical === "simplex") return `${dimension}-simplex`;
        if (canonical === "orthoplex") return `${dimension}D orthoplex`;
        return `${dimension}D cube`;
      }

      function edgePairsFromIndices(indexArray) {
        const pairs = new Array(Math.floor(indexArray.length / 2));
        for (let i = 0; i < indexArray.length; i += 2) {
          pairs[i / 2] = [indexArray[i], indexArray[i + 1]];
        }
        return pairs;
      }

      function buildEdgeIndexArray(edges) {
        const typed = new Uint32Array(edges.length * 2);
        for (let i = 0; i < edges.length; i++) {
          typed[i * 2] = edges[i][0];
          typed[i * 2 + 1] = edges[i][1];
        }
        return typed;
      }

      function buildRotationPlanes(dimension) {
        const pairs = [];
        const planeCount = (dimension * (dimension - 1)) / 2;
        const flat = new Uint32Array(planeCount * 2);
        let offset = 0;
        for (let i = 0; i < dimension; i++) {
          for (let j = i + 1; j < dimension; j++) {
            pairs.push([i, j]);
            flat[offset++] = i;
            flat[offset++] = j;
          }
        }
        return { pairs, flat };
      }

      function buildProjectionMatrix(dimension) {
        const dim = Math.max(1, dimension);
        const matrix = new Float32Array(dim * 2);
        if (dim === 1) {
          matrix[0] = 1;
          matrix[1] = 0;
          return matrix;
        }
        if (dim === 2) {
          matrix[0] = 1;
          matrix[1] = 0;
          matrix[2] = 0;
          matrix[3] = 1;
          return matrix;
        }
        const normalization = Math.sqrt(dim);
        for (let idx = 0; idx < dim; idx++) {
          const theta = (2 * Math.PI * idx) / dim;
          matrix[idx] = Math.cos(theta) / normalization;
          matrix[dim + idx] = Math.sin(theta) / normalization;
        }
        return matrix;
      }

      function computeScale(dimension, shapeName) {
        const dimValue = Math.max(2, dimension);
        const canonical = canonicalShapeName(shapeName);
        if (canonical === "simplex") {
          return CONFIG.simplexBaseScale * Math.sqrt(dimValue / 3);
        }
        if (canonical === "orthoplex") {
          return CONFIG.orthoplexBaseScale * Math.sqrt(dimValue / 3);
        }
        return CONFIG.cubeBaseScale * Math.sqrt(4 / dimValue);
      }

      function viewportScaleFactor() {
        return CONFIG.screenWidth / BASE_CANVAS_WIDTH;
      }

      function updateRenderScaleForViewport() {
        if (!state.polytope) return;
        const shapeName = CONFIG.shapes[state.shapeIndex];
        state.renderScale = computeScale(state.dimension, shapeName) * viewportScaleFactor() * state.zoom;
      }

      function rebuildState() {
        const shapeName = CONFIG.shapes[state.shapeIndex];
        const polytope = buildPolytope(shapeName, state.dimensionSetting);
        const { pairs, flat } = buildRotationPlanes(polytope.dimension);
        state.polytope = polytope;
        state.dimension = polytope.dimension;
        state.vertexCount = polytope.vertexCount;
        state.planes = pairs;
        state.planesFlat = flat;
        state.angles = new Float32Array(pairs.length);
        state.projectionMatrix = buildProjectionMatrix(polytope.dimension);
        state.renderScale = computeScale(polytope.dimension, shapeName) * viewportScaleFactor() * state.zoom;
        state.selectedPlaneIdx = pairs.length ? Math.min(state.selectedPlaneIdx, pairs.length - 1) : 0;
        if (glResources) {
          uploadEdgeIndices(glResources, polytope.edgeIndices, state.vertexCount);
        }
        updateControlStates();
      }

      function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }

      function adjustShape(delta) {
        state.shapeIndex = (state.shapeIndex + delta + CONFIG.shapes.length) % CONFIG.shapes.length;
        rebuildState();
      }

      function adjustDimension(delta) {
        state.dimensionSetting = Math.max(2, state.dimensionSetting + delta);
        rebuildState();
      }

      function resetToDefaults() {
        state.shapeIndex = 0;
        state.dimensionSetting = 3;
        state.zoom = 1;
        state.panX = 0;
        state.panY = 0;
        rebuildState();
      }

      function cyclePlane(delta) {
        if (!state.planes.length) return;
        state.selectedPlaneIdx = (state.selectedPlaneIdx + delta + state.planes.length) % state.planes.length;
      }

      function zeroSelectedPlane() {
        if (!state.planes.length) return;
        state.angles[state.selectedPlaneIdx] = 0;
      }

      function resetAllAngles() {
        if (!state.angles.length) return;
        state.angles.fill(0);
      }

      function setRotationKey(key, isDown) {
        if (isDown) {
          state.keyState.add(key);
        } else {
          state.keyState.delete(key);
        }
      }

      function adjustZoom(multiplier) {
        const next = state.zoom * multiplier;
        if (!Number.isFinite(next) || next <= 0) return;
        if (Math.abs(next - state.zoom) < 0.0001) return;
        const ratio = next / state.zoom;
        state.zoom = next;
        state.panX *= ratio;
        state.panY *= ratio;
        updateRenderScaleForViewport();
      }

      function panStep() {
        return 500;
      }

      function adjustPan(dx, dy) {
        state.panX -= dx;
        state.panY -= dy;
      }

      function handleKeyDown(event) {
        const key = event.key;
        const needsPrevent = ["Tab", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "a", "s", "d", "W", "A", "S", "D"].includes(key);
        if (needsPrevent) event.preventDefault();
        if (key === "Tab") {
          const delta = event.shiftKey ? -1 : 1;
          adjustShape(delta);
          return;
        }
        if (key === "-") {
          adjustDimension(-1);
          return;
        }
        if (key === "=" || key === "+") {
          adjustDimension(1);
          return;
        }
        if (key === "Escape") {
          resetToDefaults();
          return;
        }
        if (!state.planes.length) return;
        if (key === "ArrowUp") {
          cyclePlane(1);
        } else if (key === "ArrowDown") {
          cyclePlane(-1);
        } else if (key === "/" || key === "?") {
          zeroSelectedPlane();
        } else if (key === "r" || key === "R") {
          resetAllAngles();
        }
        if (key === "w" || key === "W") continuousInputs.panUp = true;
        if (key === "s" || key === "S") continuousInputs.panDown = true;
        if (key === "a" || key === "A") continuousInputs.panLeft = true;
        if (key === "d" || key === "D") continuousInputs.panRight = true;
      }

      function handleKeyChange(event, isDown) {
        const key = event.key;
        if (key === "ArrowLeft" || key === "ArrowRight") {
          setRotationKey(key, isDown);
        }
        if (key === "w" || key === "W") continuousInputs.panUp = isDown;
        if (key === "s" || key === "S") continuousInputs.panDown = isDown;
        if (key === "a" || key === "A") continuousInputs.panLeft = isDown;
        if (key === "d" || key === "D") continuousInputs.panRight = isDown;
      }

      window.addEventListener("keydown", (event) => {
        handleKeyDown(event);
        handleKeyChange(event, true);
      });
      window.addEventListener("keyup", (event) => handleKeyChange(event, false));
      window.addEventListener("blur", () => state.keyState.clear());

      function update(dt) {
        if (!state.planes.length) return;
        const increment = CONFIG.manualRotationSpeed * dt;
        if (state.keyState.has("ArrowLeft")) {
          state.angles[state.selectedPlaneIdx] = (state.angles[state.selectedPlaneIdx] - increment) % (Math.PI * 2);
        }
        if (state.keyState.has("ArrowRight")) {
          state.angles[state.selectedPlaneIdx] = (state.angles[state.selectedPlaneIdx] + increment) % (Math.PI * 2);
        }
        const zoomSpeed = 1 + dt * 1.2;
        if (continuousInputs.zoomIn) {
          adjustZoom(zoomSpeed);
        }
        if (continuousInputs.zoomOut) {
          adjustZoom(1 / zoomSpeed);
        }
        const panDistance = panStep() * dt;
        if (continuousInputs.panUp) adjustPan(0, -panDistance);
        if (continuousInputs.panDown) adjustPan(0, panDistance);
        if (continuousInputs.panLeft) adjustPan(-panDistance, 0);
        if (continuousInputs.panRight) adjustPan(panDistance, 0);
      }

      function renderHud() {
        if (!state.polytope) return;
        const lines = [
          `shape ${state.shapeIndex + 1}/${CONFIG.shapes.length} = ${state.polytope.name}`,
          `N=${state.dimension}  vertices=${state.vertexCount}  planes=${state.planes.length}`,
          `zoom ${(state.zoom * 100).toFixed(0)}%`,
          state.touchMode ? "Use on-screen controls plus the left pad to pan and right buttons to zoom." : "TAB next  Shift+TAB prev  -/= change N",
        ];
        if (state.planes.length) {
          const plane = state.planes[state.selectedPlaneIdx];
          const angle = state.angles[state.selectedPlaneIdx] || 0;
          const angleDeg = ((angle * 180) / Math.PI + 360) % 360;
          lines.push(`Plane ${state.selectedPlaneIdx + 1}/${state.planes.length}: (${plane[0]}, ${plane[1]})  angle=${angleDeg.toFixed(1)}°`);
          if (!state.touchMode) {
            lines.push("↑/↓ plane  hold ←/→ rotate  / zero  R reset all");
          }
        } else {
          lines.push("No rotation planes available for this dimension.");
        }
        hud.innerHTML = lines.map((line) => `<div>${line}</div>`).join("");
      }

      function rotateProjectWithWasm() {
        if (!wasmSupport.ready || !state.polytope) return null;
        return wasmSupport.rotate(
          state.polytope.vertices,
          state.planesFlat,
          state.angles,
          state.projectionMatrix,
          state.dimension,
          CONFIG.screenWidth / 2,
          CONFIG.screenHeight / 2,
          state.renderScale
        );
      }

      function rotateProjectFallback() {
        if (!state.polytope) return null;
        const { dimension, vertexCount, vertices } = state.polytope;
        const buffer = new Float32Array(vertexCount * 3);
        const coords = new Float32Array(dimension);
        for (let v = 0; v < vertexCount; v++) {
          const offset = v * dimension;
          for (let d = 0; d < dimension; d++) {
            coords[d] = vertices[offset + d];
          }
          for (let idx = 0; idx < state.planes.length; idx++) {
            const angle = state.angles[idx];
            if (!angle) continue;
            const [i, j] = state.planes[idx];
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            const ci = coords[i] * c - coords[j] * s;
            const cj = coords[i] * s + coords[j] * c;
            coords[i] = ci;
            coords[j] = cj;
          }
          let projX = 0;
          let projY = 0;
          for (let d = 0; d < dimension; d++) {
            projX += coords[d] * state.projectionMatrix[d];
            projY += coords[d] * state.projectionMatrix[dimension + d];
          }
          const screenX = CONFIG.screenWidth / 2 + projX * state.renderScale;
          const screenY = CONFIG.screenHeight / 2 + projY * state.renderScale;
          let depth = 0;
          if (dimension <= 2) {
            depth = coords[dimension - 1] ?? 0;
          } else {
            let sum = 0;
            for (let d = 2; d < dimension; d++) sum += coords[d];
            depth = sum / (dimension - 2);
          }
          const base = v * 3;
          buffer[base] = screenX;
          buffer[base + 1] = screenY;
          buffer[base + 2] = depth;
        }
        return buffer;
      }

      function drawScene() {
        if (!state.polytope) return;

        const frameBuffer = wasmSupport.ready ? rotateProjectWithWasm() : rotateProjectFallback();
        if (!frameBuffer) return;

        if (glResources) {
          drawWebGL(glResources, frameBuffer);
        } else if (ctx) {
          drawCanvas2d(ctx, frameBuffer);
        }

        renderHud();
      }

      function drawCanvas2d(context, frameBuffer) {
        context.fillStyle = CONFIG.background;
        context.fillRect(0, 0, CONFIG.screenWidth, CONFIG.screenHeight);

        const panX = state.panX;
        const panY = state.panY;
        const xAt = (idx) => frameBuffer[idx * 3] + panX;
        const yAt = (idx) => frameBuffer[idx * 3 + 1] + panY;
        const depthAt = (idx) => frameBuffer[idx * 3 + 2];

        const sortedEdges = state.polytope.edges.slice().sort((a, b) => depthAt(a[0]) + depthAt(a[1]) - (depthAt(b[0]) + depthAt(b[1])));

        context.lineWidth = 2;
        context.lineCap = "round";

        for (const edge of sortedEdges) {
          const depth = (depthAt(edge[0]) + depthAt(edge[1])) / 2;
          const shade = clamp((depth + 2) / 4, 0, 1);
          const color = CONFIG.edgeColor.map((component) => Math.round(component * shade));
          context.strokeStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
          context.beginPath();
          context.moveTo(xAt(edge[0]), yAt(edge[0]));
          context.lineTo(xAt(edge[1]), yAt(edge[1]));
          context.stroke();
        }

        const pointRadius = 4;
        for (let i = 0; i < state.vertexCount; i++) {
          const shade = clamp((depthAt(i) + 2) / 4, 0, 1);
          const color = CONFIG.pointColor.map((component) => Math.round(component * shade));
          context.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
          context.beginPath();
          context.arc(xAt(i), yAt(i), pointRadius, 0, Math.PI * 2);
          context.fill();
        }
      }

      function drawWebGL(resources, frameBuffer) {
        const { gl, program, vertexBuffer, edgeIndexBuffer, attribPosition, attribShade, uniformBaseColor, uniformPointSize, indexCount, indexType } =
          resources;

        gl.viewport(0, 0, CONFIG.screenWidth, CONFIG.screenHeight);
        gl.clearColor(8 / 255, 10 / 255, 18 / 255, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        updateVertexBuffer(resources, frameBuffer);

        gl.useProgram(program);
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.enableVertexAttribArray(attribPosition);
        gl.vertexAttribPointer(attribPosition, 3, gl.FLOAT, false, 16, 0);
        gl.enableVertexAttribArray(attribShade);
        gl.vertexAttribPointer(attribShade, 1, gl.FLOAT, false, 16, 12);

        if (indexCount > 0) {
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, edgeIndexBuffer);
          gl.uniform3fv(uniformBaseColor, normalizeColor(CONFIG.edgeColor));
          gl.uniform1f(uniformPointSize, 1.0);
          gl.drawElements(gl.LINES, indexCount, indexType, 0);
        }

        gl.uniform3fv(uniformBaseColor, normalizeColor(CONFIG.pointColor));
        gl.uniform1f(uniformPointSize, 6.0);
        gl.drawArrays(gl.POINTS, 0, state.vertexCount);
      }

      function updateVertexBuffer(resources, frameBuffer) {
        const { gl, vertexBuffer } = resources;
        const count = state.vertexCount;
        const stride = 4; // x, y, z, shade
        if (resources.vertexData.length !== count * stride) {
          resources.vertexData = new Float32Array(count * stride);
        }
        const halfW = CONFIG.screenWidth / 2;
        const halfH = CONFIG.screenHeight / 2;
        const panX = state.panX;
        const panY = state.panY;
        for (let i = 0; i < count; i++) {
          const base = i * 3;
          const x = frameBuffer[base] + panX;
          const y = frameBuffer[base + 1] + panY;
          const depth = frameBuffer[base + 2];
          const shade = clamp((depth + 2) / 4, 0, 1);
          const xClip = x / halfW - 1;
          const yClip = 1 - y / halfH;
          const zClip = shade * 2 - 1;
          const offset = i * stride;
          resources.vertexData[offset] = xClip;
          resources.vertexData[offset + 1] = yClip;
          resources.vertexData[offset + 2] = zClip;
          resources.vertexData[offset + 3] = shade;
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, resources.vertexData, gl.DYNAMIC_DRAW);
      }

      function normalizeColor(color) {
        return new Float32Array([color[0] / 255, color[1] / 255, color[2] / 255]);
      }

      function initWebGL(gl) {
        const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
        const supportsUint32 = isWebGL2 || !!gl.getExtension("OES_element_index_uint");

        const vertexSource = `
          attribute vec3 aPosition;
          attribute float aShade;
          varying float vShade;
          uniform float uPointSize;
          void main() {
            gl_Position = vec4(aPosition, 1.0);
            gl_PointSize = uPointSize;
            vShade = clamp(aShade, 0.0, 1.0);
          }
        `;

        const fragmentSource = `
          precision mediump float;
          varying float vShade;
          uniform vec3 uBaseColor;
          void main() {
            gl_FragColor = vec4(uBaseColor * vShade, 1.0);
          }
        `;

        const program = createProgram(gl, vertexSource, fragmentSource);

        const attribPosition = gl.getAttribLocation(program, "aPosition");
        const attribShade = gl.getAttribLocation(program, "aShade");
        const uniformBaseColor = gl.getUniformLocation(program, "uBaseColor");
        const uniformPointSize = gl.getUniformLocation(program, "uPointSize");

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.clearDepth(1.0);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        const vertexBuffer = gl.createBuffer();
        const edgeIndexBuffer = gl.createBuffer();

        return {
          gl,
          program,
          attribPosition,
          attribShade,
          uniformBaseColor,
          uniformPointSize,
          vertexBuffer,
          edgeIndexBuffer,
          supportsUint32,
          indexCount: 0,
          indexType: gl.UNSIGNED_SHORT,
          vertexData: new Float32Array(0),
        };
      }

      function createProgram(gl, vertexSource, fragmentSource) {
        const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          throw new Error(`WebGL program link failed: ${gl.getProgramInfoLog(program)}`);
        }
        return program;
      }

      function compileShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          throw new Error(`WebGL shader compile error: ${gl.getShaderInfoLog(shader)}`);
        }
        return shader;
      }

      function uploadEdgeIndices(resources, source, vertexCount) {
        const { gl, supportsUint32, edgeIndexBuffer } = resources;
        if (!source || source.length === 0) {
          resources.indexCount = 0;
          return;
        }
        let typed;
        if (source instanceof Uint16Array || source instanceof Uint32Array) {
          typed = source;
        } else {
          typed = buildEdgeIndexArray(source);
        }
        let indexType = gl.UNSIGNED_SHORT;
        if (typed instanceof Uint32Array) {
          if (supportsUint32) {
            indexType = gl.UNSIGNED_INT;
          } else {
            if (vertexCount - 1 > 65535) {
              console.warn("WebGL implementation lacks Uint32 indices; edges beyond 65k vertices may be truncated.");
            }
            const converted = new Uint16Array(typed.length);
            converted.set(typed);
            typed = converted;
          }
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, edgeIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, typed, gl.STATIC_DRAW);
        resources.indexCount = typed.length;
        resources.indexType = indexType;
      }

      function resizeCanvas() {
        const cssWidth = canvas.clientWidth || BASE_CANVAS_WIDTH;
        const cssHeight = canvas.clientHeight || (cssWidth * BASE_CANVAS_HEIGHT) / BASE_CANVAS_WIDTH;
        const pixelRatio = window.devicePixelRatio || 1;
        const displayWidth = Math.round(cssWidth * pixelRatio);
        const displayHeight = Math.round(cssHeight * pixelRatio);
        if (canvas.width === displayWidth && canvas.height === displayHeight) {
          return;
        }
        canvas.width = displayWidth;
        canvas.height = displayHeight;
        CONFIG.screenWidth = displayWidth;
        CONFIG.screenHeight = displayHeight;
        if (gl) {
          gl.viewport(0, 0, displayWidth, displayHeight);
        }
        updateRenderScaleForViewport();
      }

      function setupButtonControls() {
        const buttons = document.querySelectorAll("[data-action]");
        buttons.forEach((button) => {
          button.setAttribute("type", "button");
          const action = button.dataset.action;
          buttonRefs[action] = button;
          if (action === "rotate-left" || action === "rotate-right") {
            const key = action === "rotate-left" ? "ArrowLeft" : "ArrowRight";
            bindRotateButton(button, key);
            return;
          }
          if (action === "zoom-in" || action === "zoom-out") {
            bindContinuousButton(button, {
              flagKey: action === "zoom-in" ? "zoomIn" : "zoomOut",
            });
            return;
          }
          if (action === "pan-up" || action === "pan-down" || action === "pan-left" || action === "pan-right") {
            const flagKey = action === "pan-up" ? "panUp" : action === "pan-down" ? "panDown" : action === "pan-left" ? "panLeft" : "panRight";
            bindContinuousButton(button, { flagKey });
            return;
          }
          const handler = ACTION_HANDLERS[action];
          if (!handler) return;
          button.addEventListener("click", (event) => {
            event.preventDefault();
            handler();
          });
        });
        updateControlStates();
      }

      function bindRotateButton(button, key) {
        const activate = () => {
          if (!state.planes.length) return;
          setRotationKey(key, true);
          button.classList.add("active");
        };
        const deactivate = () => {
          setRotationKey(key, false);
          button.classList.remove("active");
        };
        const releasePointer = (event) => {
          if (event && event.pointerId !== undefined && button.hasPointerCapture?.(event.pointerId)) {
            button.releasePointerCapture(event.pointerId);
          }
          deactivate();
        };
        button.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          button.setPointerCapture?.(event.pointerId);
          activate();
        });
        button.addEventListener("pointerup", releasePointer);
        button.addEventListener("pointercancel", releasePointer);
        button.addEventListener("pointerleave", () => deactivate());
        button.addEventListener("lostpointercapture", () => deactivate());
        rotationButtonBindings.push({ button, deactivate });
      }

      function updateControlStates() {
        const hasPlanes = state.planes.length > 0;
        const planeDependent = ["plane-prev", "plane-next", "plane-zero", "reset-angles"];
        planeDependent.forEach((action) => {
          const btn = buttonRefs[action];
          if (btn) btn.disabled = !hasPlanes;
        });
        rotationButtonBindings.forEach(({ button, deactivate }) => {
          if (!hasPlanes) deactivate();
          button.disabled = !hasPlanes;
        });
      }

      function bindContinuousButton(button, options) {
        const { flagKey, onStart } = options;
        const activate = () => {
          continuousInputs[flagKey] = true;
          button.classList.add("active");
          onStart?.();
        };
        const deactivate = () => {
          continuousInputs[flagKey] = false;
          button.classList.remove("active");
        };
        const releasePointer = (event) => {
          if (event && event.pointerId !== undefined && button.hasPointerCapture?.(event.pointerId)) {
            button.releasePointerCapture(event.pointerId);
          }
          deactivate();
        };
        button.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          button.setPointerCapture?.(event.pointerId);
          activate();
        });
        button.addEventListener("pointerup", releasePointer);
        button.addEventListener("pointercancel", releasePointer);
        button.addEventListener("pointerleave", () => deactivate());
        button.addEventListener("lostpointercapture", () => deactivate());
      }

      function loop(timestamp) {
        const dt = (timestamp - state.lastTime) / 1000;
        state.lastTime = timestamp;
        update(dt);
        drawScene();
        requestAnimationFrame(loop);
      }

      async function bootstrap() {
        try {
          const wasmModule = await import("./pkg/projection_wasm.js");
          await wasmModule.default();
          wasmSupport.ready = true;
          wasmSupport.rotate = wasmModule.rotate_project;
          console.info("WebAssembly acceleration enabled.");
        } catch (error) {
          console.warn("Falling back to pure JS projection", error);
        }

        rebuildState();
        renderHud();
        requestAnimationFrame((ts) => {
          state.lastTime = ts;
          loop(ts);
        });
      }

      bootstrap();
    </script>
  </body>
</html>
